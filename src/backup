void Ut::FeedData(std::vector<UtSensor> data, double robot_x, double robot_y, double robot_yaw)
{
  LOG(INFO) << "START UT COMPUTE";
  for (int i = 0; i < data.size(); i++) {
    LOG(INFO) << "Update" << i << " :angle " << data[i].theta;
    max_angle_ = data[i].fov / 2;
    phi_v_ = data[i].max_dis;
    inflate_cone_ = 0;
    // calculate the bound
    double min_x, min_y, max_x, max_y, tx, ty, sensor;
    int Ax, Ay, Bx, By, Ox, Oy;
    if (data[i].detect_dis > MAX_DETECT_DIS)
      continue;
    std::pair<double, double> world, obstacle_in_robot;
    min_x = min_y = max_x = max_y = 0;
    tx = cos(data[i].toward_angle - max_angle_) * data[i].detect_dis * 1.2;
    ty = sin(data[i].toward_angle - max_angle_) * data[i].detect_dis * 1.2;
    min_x = std::min(tx, min_x);
    min_y = std::min(ty, min_y);
    max_x = std::max(tx, max_x);
    max_y = std::max(ty, max_y);
    tx = cos(data[i].toward_angle + max_angle_) * data[i].detect_dis * 1.2;
    ty = sin(data[i].toward_angle + max_angle_) * data[i].detect_dis * 1.2;
    min_x = std::min(tx, min_x);
    min_y = std::min(ty, min_y);
    max_x = std::max(tx, max_x);
    max_y = std::max(ty, max_y);
    int grid_min_x, grid_min_y, grid_max_x, grid_max_y;
    grid_min_x = int(min_x / getResolution());
    grid_min_y = int(min_y / getResolution());
    grid_max_x = int(max_x / getResolution());
    grid_max_y = int(max_y / getResolution());
    for (int x = grid_min_x; x <= grid_max_x; x++) {
      for (int y = grid_min_y; y <= grid_max_y; y++) {
        bool update_xy_cell = true;
        if (inflate_cone_ < 1.0) {
          // Determine barycentric coordinates
          int w0 = orient2d(Ax, Ay, Bx, By, x, y);
          int w1 = orient2d(Bx, By, Ox, Oy, x, y);
          int w2 = orient2d(Ox, Oy, Ax, Ay, x, y);

          // Barycentric coordinates inside area threshold; this is not mathematically sound at all, but it works!
          float bcciath = -inflate_cone_ * area(Ax, Ay, Bx, By, Ox, Oy);
          update_xy_cell = w0 >= bcciath && w1 >= bcciath && w2 >= bcciath;
        }
        if (update_xy_cell) {
          double wx, wy;
          mapToWorld(x, y, wx, wy);
          update_cell(ox, oy, theta, data[i].detect_dis, wx, wy, clear_sensor_cone);
        }
        double phi = sqrt(x * x + y * y); // grid
        double deviation_angle = atan2(y, x);
        double theta = deviation_angle - data[i].toward_angle;
        double sensor_x_in_robot = data[i].r * cos(data[i].theta);
        double sensor_y_in_robot = data[i].r * sin(data[i].theta);
        double obstacle_x_in_sensor = phi * getResolution() * cos(deviation_angle);
        double obstacle_y_in_sensor = phi * getResolution() * sin(deviation_angle);
        obstacle_in_robot = trans_coordinate(obstacle_x_in_sensor, obstacle_y_in_sensor, 0, sensor_x_in_robot, sensor_y_in_robot);
        world = trans_coordinate(obstacle_in_robot.first, obstacle_in_robot.second, robot_yaw, robot_x, robot_y);
        auto grid_world = ToGridMapPos(world.first, world.second);
        sensor = 0;
        if (phi * getResolution() >= data[i].detect_dis) {
          sensor = SensorModel(data[i].detect_dis, phi * getResolution(), theta);
        }
        double prior = getPreProb(grid_world.first, grid_world.second);
        double prob_occ = sensor * prior;
        double prob_not = (1 - sensor) * (1 - prior);
        probability_map_[std::make_pair(grid_world.first, grid_world.second)] = prob_occ / (prob_occ + prob_not);
      }
    }
  }
  LOG(INFO) << "FINISH UT COMPUTE";
}
